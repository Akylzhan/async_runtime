        -:    0:Source:/home/df/Documents/workspace/async_runtime/include/ar/array.hpp
        -:    0:Graph:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/io_executor.cpp.gcno
        -:    0:Data:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/io_executor.cpp.gcda
        -:    0:Runs:1
        -:    1:#ifndef AR_ARRAY_H
        -:    2:#define AR_ARRAY_H
        -:    3:
        -:    4:#include <atomic>
        -:    5:#include <vector>
        -:    6:#include <cassert>
        -:    7:#include <cstdint>
        -:    8:#include <cstddef>
        -:    9:#include <cstdlib>
        -:   10:#include <optional>
        -:   11:
        -:   12:
        -:   13:namespace AsyncRuntime {
        -:   14:
        -:   15:
        -:   16:    /**
        -:   17:     * @struct Array
        -:   18:     * @brief Lock-free array
        -:   19:     */
        -:   20:    template<typename T>
        -:   21:    struct AtomicArray {
        -:   22:        int64_t C;
        -:   23:        int64_t M;
        -:   24:        std::atomic_size_t U;
        -:   25:        std::atomic<T> *S;
        -:   26:
        -:   27:
function _ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEEC2El called 1 returned 100% blocks executed 89%
        1:   28:        explicit AtomicArray(int64_t c) :
        1:   29:                C{c},
        1:   30:                M{c - 1},
        1:   31:                U{0},
        1:   31-block  0
call    0 returned 1
    1025*:   32:                S{new std::atomic<T>[static_cast<size_t>(C)]} {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   32-block  0
    %%%%%:   32-block  1
call    2 never executed
        1:   32-block  2
call    3 returned 1
     1024:   32-block  3
     1025:   32-block  4
branch  4 taken 1024
branch  5 taken 1 (fallthrough)
        1:   33:        }
        -:   34:
        -:   35:
function _ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEED2Ev called 1 returned 100% blocks executed 100%
        1:   36:        ~AtomicArray() {
        1:   37:            delete[] S;
        1:   37-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   37-block  1
call    2 returned 1
        1:   38:        }
        -:   39:
        -:   40:
function _ZNK12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE8capacityEv called 4 returned 100% blocks executed 100%
        4:   41:        int64_t capacity() const noexcept {
        4:   42:            return C;
        4:   42-block  0
        -:   43:        }
        -:   44:
        -:   45:
        -:   46:        size_t size() const noexcept {
        -:   47:            return U.load(std::memory_order_relaxed);
        -:   48:        }
        -:   49:
        -:   50:
        -:   51:        template<typename O>
       4*:   52:        void store(int64_t i, O &&o) {
       4*:   53:            S[i & M].store(std::forward<O>(o), std::memory_order_relaxed);
       4*:   54:            U.fetch_add(1, std::memory_order_relaxed);
       4*:   55:        }
------------------
_ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE5storeIS2_EEvlOT_:
function _ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE5storeIS2_EEvlOT_ called 0 returned 0% blocks executed 0%
    #####:   52:        void store(int64_t i, O &&o) {
    #####:   53:            S[i & M].store(std::forward<O>(o), std::memory_order_relaxed);
    %%%%%:   53-block  0
call    0 never executed
call    1 never executed
    #####:   54:            U.fetch_add(1, std::memory_order_relaxed);
    #####:   55:        }
------------------
_ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE5storeIRS2_EEvlOT_:
function _ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE5storeIRS2_EEvlOT_ called 4 returned 100% blocks executed 100%
        4:   52:        void store(int64_t i, O &&o) {
        4:   53:            S[i & M].store(std::forward<O>(o), std::memory_order_relaxed);
        4:   53-block  0
call    0 returned 4
call    1 returned 4
        4:   54:            U.fetch_add(1, std::memory_order_relaxed);
        4:   55:        }
------------------
        -:   56:
        -:   57:
function _ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE4loadEl called 4 returned 100% blocks executed 100%
        4:   58:        T load(int64_t i) noexcept {
        4:   59:            return S[i & M].load(std::memory_order_relaxed);
        4:   59-block  0
call    0 returned 4
        -:   60:        }
        -:   61:
        -:   62:
        -:   63:        T operator [](int64_t i) noexcept {
        -:   64:            return S[i & M].load(std::memory_order_relaxed);
        -:   65:        }
        -:   66:
        -:   67:
function _ZN12AsyncRuntime11AtomicArrayIPNS_6IOTaskEE6resizeEll called 0 returned 0% blocks executed 0%
    #####:   68:        AtomicArray *resize(int64_t b, int64_t t) {
    #####:   69:            auto *ptr = new AtomicArray{2 * C};
    %%%%%:   69-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$:   69-block  1
call    4 never executed
    #####:   70:            for (int64_t i = t; i != b; ++i) {
    %%%%%:   70-block  0
    %%%%%:   70-block  1
branch  0 never executed
branch  1 never executed
    #####:   71:                ptr->store(i, load(i));
    %%%%%:   71-block  0
call    0 never executed
call    1 never executed
        -:   72:            }
    #####:   73:            return ptr;
    %%%%%:   73-block  0
    %%%%%:   73-block  1
        -:   74:        }
        -:   75:    };
        -:   76:}
        -:   77:
        -:   78:#endif //AR_ARRAY_H
