        -:    0:Source:/usr/include/boost/range/begin.hpp
        -:    0:Graph:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/base64.cpp.gcno
        -:    0:Data:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/base64.cpp.gcda
        -:    0:Runs:1
        -:    1:// Boost.Range library
        -:    2://
        -:    3://  Copyright Thorsten Ottosen 2003-2004. Use, modification and
        -:    4://  distribution is subject to the Boost Software License, Version
        -:    5://  1.0. (See accompanying file LICENSE_1_0.txt or copy at
        -:    6://  http://www.boost.org/LICENSE_1_0.txt)
        -:    7://
        -:    8:// For more information, see http://www.boost.org/libs/range/
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_RANGE_BEGIN_HPP
        -:   12:#define BOOST_RANGE_BEGIN_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER)
        -:   15:# pragma once
        -:   16:#endif
        -:   17:
        -:   18:#include <boost/range/config.hpp>
        -:   19:
        -:   20:#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:   21:#include <boost/range/detail/begin.hpp>
        -:   22:#else
        -:   23:
        -:   24:#include <boost/range/iterator.hpp>
        -:   25:#include <boost/config.hpp>
        -:   26:#include <boost/config/workaround.hpp>
        -:   27:
        -:   28:namespace boost
        -:   29:{
        -:   30:
        -:   31:#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
        -:   32:namespace range_detail
        -:   33:{
        -:   34:#endif
        -:   35:
        -:   36:    //////////////////////////////////////////////////////////////////////
        -:   37:    // primary template
        -:   38:    //////////////////////////////////////////////////////////////////////
        -:   39:
        -:   40:    template< typename C >
        -:   41:    BOOST_CONSTEXPR inline BOOST_DEDUCED_TYPENAME range_iterator<C>::type
function _ZN5boost12range_detail11range_beginIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEENS_14range_iteratorIT_vE4typeERSA_ called 0 returned 0% blocks executed 0%
    #####:   42:    range_begin( C& c )
        -:   43:    {
        -:   44:        //
        -:   45:        // If you get a compile-error here, it is most likely because
        -:   46:        // you have not implemented range_begin() properly in
        -:   47:        // the namespace of C
        -:   48:        //
    #####:   49:        return c.begin();
    %%%%%:   49-block  0
call    0 never executed
        -:   50:    }
        -:   51:
        -:   52:    //////////////////////////////////////////////////////////////////////
        -:   53:    // pair
        -:   54:    //////////////////////////////////////////////////////////////////////
        -:   55:
        -:   56:    template< typename Iterator >
        -:   57:    BOOST_CONSTEXPR inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
        -:   58:    {
        -:   59:        return p.first;
        -:   60:    }
        -:   61:
        -:   62:    template< typename Iterator >
        -:   63:    BOOST_CONSTEXPR inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
        -:   64:    {
        -:   65:        return p.first;
        -:   66:    }
        -:   67:
        -:   68:    //////////////////////////////////////////////////////////////////////
        -:   69:    // array
        -:   70:    //////////////////////////////////////////////////////////////////////
        -:   71:
        -:   72:    //
        -:   73:    // May this be discarded? Or is it needed for bad compilers?
        -:   74:    //
        -:   75:    template< typename T, std::size_t sz >
        -:   76:    BOOST_CONSTEXPR inline const T* range_begin( const T (&a)[sz] ) BOOST_NOEXCEPT
        -:   77:    {
        -:   78:        return a;
        -:   79:    }
        -:   80:
        -:   81:    template< typename T, std::size_t sz >
        -:   82:    BOOST_CONSTEXPR inline T* range_begin( T (&a)[sz] ) BOOST_NOEXCEPT
        -:   83:    {
        -:   84:        return a;
        -:   85:    }
        -:   86:
        -:   87:
        -:   88:#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
        -:   89:} // namespace 'range_detail'
        -:   90:#endif
        -:   91:
        -:   92:// Use a ADL namespace barrier to avoid ambiguity with other unqualified
        -:   93:// calls. This is particularly important with C++0x encouraging
        -:   94:// unqualified calls to begin/end.
        -:   95:namespace range_adl_barrier
        -:   96:{
        -:   97:
        -:   98:template< class T >
        -:   99:#if !BOOST_WORKAROUND(BOOST_GCC, < 40700)
        -:  100:BOOST_CONSTEXPR
        -:  101:#endif
        -:  102:inline BOOST_DEDUCED_TYPENAME range_iterator<T>::type begin( T& r )
        -:  103:{
        -:  104:#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
        -:  105:    using namespace range_detail;
        -:  106:#endif
        -:  107:    return range_begin( r );
        -:  108:}
        -:  109:
        -:  110:template< class T >
        -:  111:#if !BOOST_WORKAROUND(BOOST_GCC, < 40700)
        -:  112:BOOST_CONSTEXPR
        -:  113:#endif
function _ZN5boost17range_adl_barrier5beginINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEENS_14range_iteratorIKT_vE4typeERSA_ called 0 returned 0% blocks executed 0%
    #####:  114:inline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type begin( const T& r )
        -:  115:{
        -:  116:#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
        -:  117:    using namespace range_detail;
        -:  118:#endif
    #####:  119:    return range_begin( r );
    %%%%%:  119-block  0
call    0 never executed
        -:  120:}
        -:  121:
        -:  122:    } // namespace range_adl_barrier
        -:  123:} // namespace boost
        -:  124:
        -:  125:#endif // BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  126:
        -:  127:namespace boost
        -:  128:{
        -:  129:    namespace range_adl_barrier
        -:  130:    {
        -:  131:        template< class T >
        -:  132:        inline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type
        -:  133:        const_begin( const T& r )
        -:  134:        {
        -:  135:            return boost::range_adl_barrier::begin( r );
        -:  136:        }
        -:  137:    } // namespace range_adl_barrier
        -:  138:
        -:  139:    using namespace range_adl_barrier;
        -:  140:} // namespace boost
        -:  141:
        -:  142:#endif
        -:  143:
