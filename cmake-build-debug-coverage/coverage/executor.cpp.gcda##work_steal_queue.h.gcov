        -:    0:Source:/home/df/Documents/workspace/async_runtime/include/ar/work_steal_queue.h
        -:    0:Graph:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/executor.cpp.gcno
        -:    0:Data:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/executor.cpp.gcda
        -:    0:Runs:1
        -:    1:#ifndef AR_WORKSTEALQUEUE_H
        -:    2:#define AR_WORKSTEALQUEUE_H
        -:    3:
        -:    4:
        -:    5:#include "ar/os.hpp"
        -:    6:#include "ar/array.hpp"
        -:    7:
        -:    8:
        -:    9:namespace AsyncRuntime {
        -:   10:
        -:   11:
        -:   12:    /**
        -:   13:     * @class TaskQueue
        -:   14:     * @brief Lock-free unbounded single-producer multiple-consumer queue.
        -:   15:     * @tparam T data type
        -:   16:     */
        -:   17:    template<typename T>
        -:   18:    class WorkStealQueue {
        -:   19:    public:
        -:   20:
        -:   21:        /**
        -:   22:        @brief constructs the queue with a given capacity
        -:   23:        @param capacity the capacity of the queue (must be power of 2)
        -:   24:        */
        -:   25:        explicit WorkStealQueue(int64_t capacity = 1024);
        -:   26:
        -:   27:        /**
        -:   28:        @brief destructs the queue
        -:   29:        */
        -:   30:        ~WorkStealQueue();
        -:   31:
        -:   32:        /**
        -:   33:        @brief queries if the queue is empty at the time of this call
        -:   34:        */
        -:   35:        bool empty() const noexcept;
        -:   36:
        -:   37:        /**
        -:   38:        @brief queries the number of items at the time of this call
        -:   39:        */
        -:   40:        size_t size() const noexcept;
        -:   41:
        -:   42:        /**
        -:   43:        @brief queries the capacity of the queue
        -:   44:        */
        -:   45:        int64_t capacity() const noexcept;
        -:   46:
        -:   47:        /**
        -:   48:        @brief inserts an item to the queue
        -:   49:        Only the owner thread can insert an item to the queue.
        -:   50:        The operation can trigger the queue to resize its capacity
        -:   51:        if more space is required.
        -:   52:        @tparam O data type
        -:   53:        @param item the item to perfect-forward to the queue
        -:   54:        */
        -:   55:        template<typename O>
        -:   56:        void push(O &&item);
        -:   57:
        -:   58:        /**
        -:   59:        @brief pops out an item from the queue
        -:   60:        Only the owner thread can pop out an item from the queue.
        -:   61:        The return can be a @std_nullopt if this operation failed (empty queue).
        -:   62:        */
        -:   63:        std::optional<T> pop();
        -:   64:
        -:   65:        /**
        -:   66:        @brief steals an item from the queue
        -:   67:        Any threads can try to steal an item from the queue.
        -:   68:        The return can be a @std_nullopt if this operation failed (not necessary empty).
        -:   69:        */
        -:   70:        std::optional<T> steal();
        -:   71:
        -:   72:
        -:   73:    private:
        -:   74:        std::atomic<int64_t> _top;
        -:   75:        std::atomic<int64_t> _bottom;
        -:   76:        std::atomic<AtomicArray<T> *> _array;
        -:   77:        std::vector<AtomicArray<T> *> _garbage;
        -:   78:    };
        -:   79:
        -:   80:
        -:   81:    template<typename T>
function _ZN12AsyncRuntime14WorkStealQueueIPNS_4TaskEEC2El called 17 returned 100% blocks executed 78%
       17:   82:    WorkStealQueue<T>::WorkStealQueue(int64_t c) {
       17:   82-block  0
call    0 returned 17
      17*:   83:        assert(c && (!(c & (c - 1))));
branch  0 taken 17 (fallthrough)
branch  1 taken 0
       17:   83-block  0
branch  2 taken 17 (fallthrough)
branch  3 taken 0
    %%%%%:   83-block  1
call    4 never executed
       17:   84:        _top.store(0, std::memory_order_relaxed);
       17:   84-block  0
call    0 returned 17
       17:   85:        _bottom.store(0, std::memory_order_relaxed);
       17:   85-block  0
call    0 returned 17
       17:   86:        _array.store(new AtomicArray<T>{c}, std::memory_order_relaxed);
       17:   86-block  0
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0 (throw)
       17:   86-block  1
call    3 returned 17
branch  4 taken 17 (fallthrough)
branch  5 taken 0 (throw)
       17:   86-block  2
call    6 returned 17
    $$$$$:   86-block  3
call    7 never executed
       17:   87:        _garbage.reserve(32);
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0 (throw)
       17:   88:    }
       17:   88-block  0
    $$$$$:   88-block  1
call    0 never executed
        -:   89:
        -:   90:
        -:   91:    template<typename T>
function _ZN12AsyncRuntime14WorkStealQueueIPNS_4TaskEED2Ev called 17 returned 100% blocks executed 67%
       17:   92:    WorkStealQueue<T>::~WorkStealQueue() {
      17*:   93:        for (auto a: _garbage) {
       17:   93-block  0
call    0 returned 17
call    1 returned 17
    %%%%%:   93-block  1
call    2 never executed
    %%%%%:   93-block  2
call    3 never executed
       17:   93-block  3
call    4 returned 17
branch  5 taken 0
branch  6 taken 17 (fallthrough)
    #####:   94:            delete a;
branch  0 never executed
branch  1 never executed
    %%%%%:   94-block  0
call    2 never executed
call    3 never executed
        -:   95:        }
       17:   96:        delete _array.load();
       17:   96-block  0
call    0 returned 17
branch  1 taken 17 (fallthrough)
branch  2 taken 0
       17:   96-block  1
call    3 returned 17
call    4 returned 17
       17:   97:    }
       17:   97-block  0
call    0 returned 17
        -:   98:
        -:   99:
        -:  100:    template<typename T>
        -:  101:    bool WorkStealQueue<T>::empty() const noexcept {
        -:  102:        int64_t b = _bottom.load(std::memory_order_relaxed);
        -:  103:        int64_t t = _top.load(std::memory_order_relaxed);
        -:  104:        return b <= t;
        -:  105:    }
        -:  106:
        -:  107:
        -:  108:    template<typename T>
        -:  109:    size_t WorkStealQueue<T>::size() const noexcept {
        -:  110:        int64_t b = _bottom.load(std::memory_order_relaxed);
        -:  111:        int64_t t = _top.load(std::memory_order_relaxed);
        -:  112:        return static_cast<size_t>(b >= t ? b - t : 0);
        -:  113:    }
        -:  114:
        -:  115:
        -:  116:    template<typename T>
        -:  117:    template<typename O>
function _ZN12AsyncRuntime14WorkStealQueueIPNS_4TaskEE4pushIRS2_EEvOT_ called 5 returned 100% blocks executed 73%
        5:  118:    void WorkStealQueue<T>::push(O &&o) {
        5:  119:        int64_t b = _bottom.load(std::memory_order_relaxed);
        5:  119-block  0
call    0 returned 5
        5:  120:        int64_t t = _top.load(std::memory_order_acquire);
        5:  120-block  0
call    0 returned 5
        5:  121:        AtomicArray<T> *a = _array.load(std::memory_order_relaxed);
        5:  121-block  0
call    0 returned 5
        -:  122:
        -:  123:        // queue is full
        5:  124:        if (a->capacity() - 1 < (b - t)) {
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####:  125:            AtomicArray<T> *tmp = a->resize(b, t);
    %%%%%:  125-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  126:            _garbage.push_back(a);
    %%%%%:  126-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  127:            std::swap(a, tmp);
    %%%%%:  127-block  0
call    0 never executed
    #####:  128:            _array.store(a, std::memory_order_relaxed);
call    0 never executed
        -:  129:        }
        -:  130:
        5:  131:        a->store(b, std::forward<O>(o));
        5:  131-block  0
call    0 returned 5
call    1 returned 5
        -:  132:        std::atomic_thread_fence(std::memory_order_release);
        5:  133:        _bottom.store(b + 1, std::memory_order_relaxed);
        5:  133-block  0
call    0 returned 5
        5:  134:    }
        5:  134-block  0
        -:  135:
        -:  136:
        -:  137:    template<typename T>
        -:  138:    std::optional<T> WorkStealQueue<T>::pop() {
        -:  139:        int64_t b = _bottom.load(std::memory_order_relaxed) - 1;
        -:  140:        AtomicArray<T> *a = _array.load(std::memory_order_relaxed);
        -:  141:        _bottom.store(b, std::memory_order_relaxed);
        -:  142:        std::atomic_thread_fence(std::memory_order_seq_cst);
        -:  143:        int64_t t = _top.load(std::memory_order_relaxed);
        -:  144:
        -:  145:        std::optional<T> item;
        -:  146:
        -:  147:        if (t <= b) {
        -:  148:            item = a->load(b);
        -:  149:            if (t == b) {
        -:  150:                // the last item just got stolen
        -:  151:                if (!_top.compare_exchange_strong(t, t + 1,
        -:  152:                                                  std::memory_order_seq_cst,
        -:  153:                                                  std::memory_order_relaxed)) {
        -:  154:                    item = std::nullopt;
        -:  155:                }
        -:  156:                _bottom.store(b + 1, std::memory_order_relaxed);
        -:  157:            }
        -:  158:        } else {
        -:  159:            _bottom.store(b + 1, std::memory_order_relaxed);
        -:  160:        }
        -:  161:
        -:  162:        return item;
        -:  163:    }
        -:  164:
        -:  165:
        -:  166:    template<typename T>
        -:  167:    std::optional<T> WorkStealQueue<T>::steal() {
        -:  168:        int64_t t = _top.load(std::memory_order_acquire);
        -:  169:        std::atomic_thread_fence(std::memory_order_seq_cst);
        -:  170:        int64_t b = _bottom.load(std::memory_order_acquire);
        -:  171:
        -:  172:        std::optional<T> item;
        -:  173:
        -:  174:        if (t < b) {
        -:  175:            AtomicArray<T> *a = _array.load(std::memory_order_consume);
        -:  176:            item = a->load(t);
        -:  177:            if (!_top.compare_exchange_strong(t, t + 1,
        -:  178:                                              std::memory_order_seq_cst,
        -:  179:                                              std::memory_order_relaxed)) {
        -:  180:                return std::nullopt;
        -:  181:            }
        -:  182:        }
        -:  183:
        -:  184:        return item;
        -:  185:    }
        -:  186:
        -:  187:
        -:  188:    template<typename T>
        -:  189:    int64_t WorkStealQueue<T>::capacity() const noexcept {
        -:  190:        return _array.load(std::memory_order_relaxed)->capacity();
        -:  191:    }
        -:  192:}
        -:  193:
        -:  194:#endif //AR_WORKSTEALQUEUE_H
