        -:    0:Source:/home/df/Documents/workspace/async_runtime/include/ar/task.hpp
        -:    0:Graph:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/runtime.cpp.gcno
        -:    0:Data:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/CMakeFiles/ar.dir/src/runtime.cpp.gcda
        -:    0:Runs:1
        -:    1:#ifndef AR_TASK_H
        -:    2:#define AR_TASK_H
        -:    3:
        -:    4:#include <iostream>
        -:    5:#include <future>
        -:    6:#include <functional>
        -:    7:#include <typeinfo>
        -:    8:#include <cstdio>
        -:    9:#include <utility>
        -:   10:#include <atomic>
        -:   11:
        -:   12:#include "ar/helper.hpp"
        -:   13:#include "ar/object.hpp"
        -:   14:
        -:   15:
        -:   16:namespace AsyncRuntime {
        -:   17:    class Task;
        -:   18:    class Processor;
        -:   19:    class IExecutor;
        -:   20:
        -:   21:
        -:   22:    /**
        -:   23:     * @class
        -:   24:     * @brief
        -:   25:     */
        -:   26:    template<class Ret>
        -:   27:    class Result
        -:   28:    {
        -:   29:        friend class runtime;
        -:   30:    public:
        -:   31:        typedef std::function<void(void*)> resume_cb_t;
        -:   32:        typedef Ret RetType;
        -:   33:
        -:   34:        explicit Result() : excepted(false) {
        -:   35:            resolved.store(false, std::memory_order_relaxed);
        -:   36:            future = promise.get_future();
        -:   37:        };
        -:   38:
        -:   39:
        -:   40:        template<typename T>
        -:   41:        explicit Result(T && v) : excepted(false) {
        -:   42:            resolved.store(true, std::memory_order_relaxed);
        -:   43:            future = promise.get_future();
        -:   44:            promise.set_value(v);
        -:   45:        };
        -:   46:
        -:   47:
        -:   48:        Result(const Result& other) = delete;
        -:   49:        Result& operator =(const Result& other) = delete;
        -:   50:        Result(Result&& other) = delete;
        -:   51:        Result& operator =(Result&& other) = delete;
        -:   52:
        -:   53:
        -:   54:        ~Result() = default;
        -:   55:
        -:   56:
        -:   57:        /**
        -:   58:         * @brief
        -:   59:         * @param function
        -:   60:         */
        -:   61:        bool Then(const resume_cb_t& cb, void* opaque = nullptr) {
        -:   62:            std::lock_guard<std::mutex>   lock(resolve_mutex);
        -:   63:            if(!resolved.load(std::memory_order_relaxed)) {
        -:   64:                completed_opaque = opaque;
        -:   65:                completed_cb = cb;
        -:   66:                return true;
        -:   67:            }else{
        -:   68:                return false;
        -:   69:            }
        -:   70:        }
        -:   71:
        -:   72:
        -:   73:        /**
        -:   74:         * @brief
        -:   75:         */
        -:   76:        Result<Ret>* Wait() {
        -:   77:            if(!resolved.load(std::memory_order_relaxed)) {
        -:   78:                if (future.valid())
        -:   79:                    future.wait();
        -:   80:            }
        -:   81:
        -:   82:            return this;
        -:   83:        }
        -:   84:
        -:   85:
        -:   86:        /**
        -:   87:         * @brief
        -:   88:         * @param v
        -:   89:         */
        -:   90:        template<typename T>
        -:   91:        void SetValue(T && v) {
        -:   92:            std::lock_guard<std::mutex>   lock(resolve_mutex);
        -:   93:            resolved.store(true, std::memory_order_relaxed);
        -:   94:
        -:   95:            if(!excepted) {
        -:   96:                promise.set_value(v);
        -:   97:
        -:   98:                if (completed_cb)
        -:   99:                    completed_cb(completed_opaque);
        -:  100:
        -:  101:                completed_cb = nullptr;
        -:  102:            }
        -:  103:        }
        -:  104:
        -:  105:
        -:  106:        /**
        -:  107:         * @brief
        -:  108:         * @param v
        -:  109:         */
        -:  110:        void SetValue() {
        -:  111:            std::lock_guard<std::mutex>   lock(resolve_mutex);
        -:  112:            resolved.store(true, std::memory_order_relaxed);
        -:  113:
        -:  114:            if(!excepted) {
        -:  115:                promise.set_value();
        -:  116:
        -:  117:                if (completed_cb)
        -:  118:                    completed_cb(completed_opaque);
        -:  119:
        -:  120:                completed_cb = nullptr;
        -:  121:            }
        -:  122:        }
        -:  123:
        -:  124:
        -:  125:        /**
        -:  126:         * @brief
        -:  127:         * @param __p
        -:  128:         */
        -:  129:        void SetException(std::exception_ptr e) {
        -:  130:            std::lock_guard<std::mutex>   lock(resolve_mutex);
        -:  131:            resolved.store(true, std::memory_order_relaxed);
        -:  132:            promise.set_exception(e);
        -:  133:            excepted = true;
        -:  134:        }
        -:  135:
        -:  136:
        -:  137:        /**
        -:  138:         * @brief
        -:  139:         * @return
        -:  140:         */
        -:  141:        Ret Get() {
        -:  142:            if(future.valid()) {
        -:  143:                return future.get();
        -:  144:            } else {
        -:  145:                throw std::runtime_error("invalid future");
        -:  146:            }
        -:  147:        }
        -:  148:
        -:  149:
        -:  150:        /**
        -:  151:         * @brief
        -:  152:         * @return
        -:  153:         */
        -:  154:        bool Valid() const { return future.valid(); }
        -:  155:
        -:  156:
        -:  157:        /**
        -:  158:         * @brief
        -:  159:         * @return
        -:  160:         */
        -:  161:        bool Resolved() const {
        -:  162:            bool res = resolved.load(std::memory_order_relaxed);
        -:  163:            return res;
        -:  164:        }
        -:  165:    protected:
        -:  166:        std::future<Ret>                    future;
        -:  167:        resume_cb_t                         completed_cb;
        -:  168:        void*                               completed_opaque;
        -:  169:        std::promise<Ret>                   promise;
        -:  170:        std::atomic_bool                    resolved;
        -:  171:        std::mutex                          resolve_mutex;
        -:  172:        bool                                excepted;
        -:  173:    };
        -:  174:
        -:  175:
        -:  176:    /**
        -:  177:     * @brief
        -:  178:     */
        -:  179:    struct ExecutorState {
        -:  180:        IExecutor*  executor = nullptr;
        -:  181:        Processor*  processor = nullptr;
        -:  182:        void*       data = nullptr;
        -:  183:    };
        -:  184:
        -:  185:
        -:  186:    /**
        -:  187:     * @class TaskImplBase
        -:  188:     * @brief Task interface
        -:  189:     */
        -:  190:    class Task
        -:  191:    {
        -:  192:        friend class runtime;
        -:  193:    public:
        -:  194:        Task() = default;
        -:  195:        virtual ~Task() = default;
        -:  196:        virtual void Execute(const ExecutorState& executor = ExecutorState()) = 0;
        -:  197:
        -:  198:
        -:  199:        void SetDesirableExecutor(const ExecutorState& executor_) { desirable_executor = executor_; }
function _ZNK12AsyncRuntime4Task20GetDesirableExecutorEv called 0 returned 0% blocks executed 0%
    #####:  200:        const ExecutorState& GetDesirableExecutor() const { return desirable_executor; }
    %%%%%:  200-block  0
        -:  201:    protected:
        -:  202:        ExecutorState executor;
        -:  203:        ExecutorState desirable_executor;
        -:  204:    };
        -:  205:
        -:  206:
        -:  207:    /**
        -:  208:     * @class Task
        -:  209:     * @brief Task container
        -:  210:     */
        -:  211:    template < class Callable  >
        -:  212:    class TaskImpl : public Task
        -:  213:    {
        -:  214:        typedef typename std::result_of<Callable(const ExecutorState&)>::type return_type;
        -:  215:    public:
        -:  216:        explicit TaskImpl(Callable&& f) :
        -:  217:                Task(),
        -:  218:                fn(f),
        -:  219:                result(new Result<return_type>() ){ };
        -:  220:
        -:  221:        ~TaskImpl() override = default;
        -:  222:
        -:  223:
        -:  224:        void Execute(const ExecutorState& executor_) override {
        -:  225:            try {
        -:  226:                executor = executor_;
        -:  227:                Handle(result.get(), fn);
        -:  228:            } catch(...) {
        -:  229:                try {
        -:  230:                    result->SetException(std::current_exception());
        -:  231:                } catch(...) { }
        -:  232:            }
        -:  233:        }
        -:  234:
        -:  235:
        -:  236:        std::shared_ptr<Result<return_type>> GetResult() {
        -:  237:            return result;
        -:  238:        }
        -:  239:    private:
        -:  240:        /**
        -:  241:         * @brief handle non-void here
        -:  242:         * @tparam F
        -:  243:         * @tparam R
        -:  244:         * @param p
        -:  245:         * @param f
        -:  246:         */
        -:  247:        template<typename F, typename R>
        -:  248:        void Handle(Result<R>* r, F && f)
        -:  249:        {
        -:  250:            auto res = f(executor);
        -:  251:            r->SetValue(res);
        -:  252:        }
        -:  253:
        -:  254:
        -:  255:        /**
        -:  256:         * @class handle void here
        -:  257:         * @tparam F
        -:  258:         * @param p
        -:  259:         * @param f
        -:  260:         */
        -:  261:        template<typename F>
        -:  262:        void Handle(Result<void>* r, F && f)
        -:  263:        {
        -:  264:            f(executor);
        -:  265:            r->SetValue();
        -:  266:        }
        -:  267:
        -:  268:
        -:  269:        Callable                                                        fn;
        -:  270:        std::shared_ptr<Result<return_type>>                            result;
        -:  271:    };
        -:  272:
        -:  273:
        -:  274:    /**
        -:  275:     * @brief
        -:  276:     * @tparam Callable
        -:  277:     * @param f
        -:  278:     * @return
        -:  279:     */
        -:  280:    template<class Fn>
        -:  281:    inline TaskImpl<Fn>* MakeTask(Fn &&f) {
        -:  282:        return new TaskImpl(std::forward<Fn>(f));
        -:  283:    }
        -:  284:
        -:  285:
        -:  286:    typedef std::shared_ptr<Result<void>>   ResultVoidPtr;
        -:  287:}
        -:  288:
        -:  289:
        -:  290:#endif //AR_TASK_H
