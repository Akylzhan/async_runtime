        -:    0:Source:/home/df/Documents/workspace/async_runtime/include/ar/io_task.hpp
        -:    0:Graph:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/examples/CMakeFiles/tcp_client.dir/tcp_client.cpp.gcno
        -:    0:Data:/home/df/Documents/workspace/async_runtime/cmake-build-debug-coverage/examples/CMakeFiles/tcp_client.dir/tcp_client.cpp.gcda
        -:    0:Runs:1
        -:    1:#ifndef AR_IO_TASK_HPP
        -:    2:#define AR_IO_TASK_HPP
        -:    3:
        -:    4:
        -:    5:#include "ar/task.hpp"
        -:    6:#include "ar/stream.hpp"
        -:    7:#include "ar/tcp.hpp"
        -:    8:#include "uv.h"
        -:    9:
        -:   10:
        -:   11:namespace AsyncRuntime {
        -:   12:    struct IOFsOpen {
        -:   13:        const char* filename;
        -:   14:        int         flags;
        -:   15:        int         mode;
        -:   16:    };
        -:   17:
        -:   18:
        -:   19:    struct IOFsRead {
        -:   20:        int64_t seek = -1;
        -:   21:        int64_t size = 0;
        -:   22:    };
        -:   23:
        -:   24:
        -:   25:    struct IOFsWrite {
        -:   26:        int64_t seek = -1;
        -:   27:    };
        -:   28:
        -:   29:
        -:   30:    struct IOFsClose {};
        -:   31:
        -:   32:
        -:   33:    struct IONetListen {
        -:   34:        int                               flags = 0;
        -:   35:        TCPSession::HandlerType           handle_connection;
        -:   36:    };
        -:   37:
        -:   38:
        -:   39:    struct IONetConnect { };
        -:   40:    struct IONetRead { uv_tcp_t *socket; };
        -:   41:    struct IONetWrite { uv_tcp_t *socket; };
        -:   42:    struct IONetClose { uv_tcp_t *socket; };
        -:   43:    struct IONetAddrInfo { };
        -:   44:
        -:   45:
        -:   46:    typedef int                                     IOResult;
        -:   47:    typedef std::shared_ptr<Result<IOResult>>       IOResultPtr;
        -:   48:
        -:   49:
        -:   50:#define IO_SUCCESS 0
        -:   51:
        -:   52:
        -:   53:    void FsOpenCb(uv_fs_s* req);
        -:   54:    void FsReadCb(uv_fs_s* req);
        -:   55:    void FsWriteCb(uv_fs_s* req);
        -:   56:    void FsCloseCb(uv_fs_s* req);
        -:   57:
        -:   58:    void NetConnectionCb(uv_stream_t *server, int status);
        -:   59:    void NetConnectionCb(uv_connect_t* connection, int status);
        -:   60:    void NetAllocCb(uv_handle_t *handle, size_t size, uv_buf_t *buf);
        -:   61:    void NetReadCb(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf);
        -:   62:    void NetWriteCb(uv_write_t* req, int status);
        -:   63:    void NetCloseCb(uv_handle_t* handle);
        -:   64:    void NetAddrInfoCb(uv_getaddrinfo_t* req, int status, struct addrinfo* res);
        -:   65:
        -:   66:    const char* FSErrorMsg(int error);
        -:   67:    const char* FSErrorName(int error);
        -:   68:
        -:   69:
        -:   70:    class IOTask : public Task {
        -:   71:    public:
function _ZN12AsyncRuntime6IOTask7ExecuteERKNS_13ExecutorStateE called 0 returned 0% blocks executed 0%
    #####:   72:        void Execute(const ExecutorState& executor_) override { throw std::runtime_error("not implemented!"); }
    %%%%%:   72-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    %%%%%:   72-block  1
call    4 never executed
    $$$$$:   72-block  2
call    5 never executed
        -:   73:        virtual bool Execute(uv_loop_t *loop) = 0;
        -:   74:    };
        -:   75:
        -:   76:
        -:   77:    template<typename Method>
        -:   78:    class IOFsTaskImpl : public IOTask
        -:   79:    {
        -:   80:    public:
        -:   81:        explicit IOFsTaskImpl(Method m, const IOStreamPtr& s) :
        -:   82:                method(m),
        -:   83:                stream(s),
        -:   84:                result(new Result<IOResult>() ) {
        -:   85:            assert(stream);
        -:   86:        };
        -:   87:
        -:   88:
        -:   89:        bool Execute(uv_loop_t *loop) {
        -:   90:            request.data = this;
        -:   91:            return CallMethod(loop);
        -:   92:        }
        -:   93:
        -:   94:
        -:   95:        void Resolve(IOResult res) {
        -:   96:            result->SetValue(res);
        -:   97:        }
        -:   98:
        -:   99:
        -:  100:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        -:  101:        const uv_fs_s* GetRequest() const { return &request; }
        -:  102:        uv_fs_s* GetRequest() { return &request; }
        -:  103:        const IOStreamPtr& GetStream() const { return stream; }
        -:  104:        const Method& GetMethod() const { return method; }
        -:  105:    private:
        -:  106:        bool CallMethod(uv_loop_t *loop);
        -:  107:
        -:  108:
        -:  109:        std::shared_ptr<Result<IOResult>>                        result;
        -:  110:        IOStreamPtr                                              stream;
        -:  111:        Method                                                   method;
        -:  112:        uv_fs_t                                                  request;
        -:  113:    };
        -:  114:
        -:  115:
        -:  116:    template<typename Method>
        -:  117:    class IONetTaskImpl : public IOTask
        -:  118:    {
        -:  119:    public:
        2:  120:        explicit IONetTaskImpl(Method m, const IOStreamPtr& s) :
        2:  121:                method(m),
        2:  122:                stream(s),
        2:  123:                result(new Result<IOResult>() ) {
        2:  124:        };
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEEC2ES1_RKSt10shared_ptrINS_8IOStreamEE:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEEC2ES1_RKSt10shared_ptrINS_8IOStreamEE called 1 returned 100% blocks executed 70%
        1:  120:        explicit IONetTaskImpl(Method m, const IOStreamPtr& s) :
        1:  121:                method(m),
        1:  122:                stream(s),
        1:  122-block  0
call    0 returned 1
        1:  123:                result(new Result<IOResult>() ) {
        1:  123-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  123-block  1
call    4 returned 1
branch  5 taken 1 (fallthrough)
branch  6 taken 0 (throw)
        1:  123-block  2
call    7 returned 1
branch  8 taken 1 (fallthrough)
branch  9 taken 0 (throw)
    $$$$$:  123-block  3
call   10 never executed
        1:  124:        };
    $$$$$:  124-block  0
call    0 never executed
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEEC2ES1_RKSt10shared_ptrINS_8IOStreamEE:
function _ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEEC2ES1_RKSt10shared_ptrINS_8IOStreamEE called 1 returned 100% blocks executed 70%
        1:  120:        explicit IONetTaskImpl(Method m, const IOStreamPtr& s) :
        1:  121:                method(m),
        1:  122:                stream(s),
        1:  122-block  0
call    0 returned 1
        1:  123:                result(new Result<IOResult>() ) {
        1:  123-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  123-block  1
call    4 returned 1
branch  5 taken 1 (fallthrough)
branch  6 taken 0 (throw)
        1:  123-block  2
call    7 returned 1
branch  8 taken 1 (fallthrough)
branch  9 taken 0 (throw)
    $$$$$:  123-block  3
call   10 never executed
        1:  124:        };
    $$$$$:  124-block  0
call    0 never executed
------------------
        -:  125:
        -:  126:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetCloseEEC2ES1_ called 1 returned 100% blocks executed 70%
        1:  127:        explicit IONetTaskImpl(Method m) :
        1:  128:                method(m),
        1:  129:                result(new Result<IOResult>() ) {
        1:  129-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  129-block  1
call    4 returned 1
branch  5 taken 1 (fallthrough)
branch  6 taken 0 (throw)
        1:  129-block  2
call    7 returned 1
branch  8 taken 1 (fallthrough)
branch  9 taken 0 (throw)
        1:  129-block  3
call   10 returned 1
    $$$$$:  129-block  4
call   11 never executed
        1:  130:        };
    $$$$$:  130-block  0
call    0 never executed
        -:  131:
        -:  132:
        3:  133:        bool Execute(uv_loop_t *loop) {
        3:  134:            return CallMethod(loop);
        -:  135:        }
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE7ExecuteEP9uv_loop_s:
function _ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE7ExecuteEP9uv_loop_s called 1 returned 100% blocks executed 100%
        1:  133:        bool Execute(uv_loop_t *loop) {
        1:  134:            return CallMethod(loop);
        1:  134-block  0
call    0 returned 1
        -:  135:        }
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE7ExecuteEP9uv_loop_s:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE7ExecuteEP9uv_loop_s called 1 returned 100% blocks executed 100%
        1:  133:        bool Execute(uv_loop_t *loop) {
        1:  134:            return CallMethod(loop);
        1:  134-block  0
call    0 returned 1
        -:  135:        }
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_10IONetCloseEE7ExecuteEP9uv_loop_s:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetCloseEE7ExecuteEP9uv_loop_s called 1 returned 100% blocks executed 100%
        1:  133:        bool Execute(uv_loop_t *loop) {
        1:  134:            return CallMethod(loop);
        1:  134-block  0
call    0 returned 1
        -:  135:        }
------------------
        -:  136:
        -:  137:
        2:  138:        void Resolve(IOResult res) {
        2:  139:            result->SetValue(res);
        2:  140:        }
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE7ResolveEi:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE7ResolveEi called 1 returned 100% blocks executed 100%
        1:  138:        void Resolve(IOResult res) {
        1:  139:            result->SetValue(res);
        1:  139-block  0
call    0 returned 1
call    1 returned 1
        1:  140:        }
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE7ResolveEi:
function _ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE7ResolveEi called 1 returned 100% blocks executed 100%
        1:  138:        void Resolve(IOResult res) {
        1:  139:            result->SetValue(res);
        1:  139-block  0
call    0 returned 1
call    1 returned 1
        1:  140:        }
------------------
        -:  141:
        -:  142:
        3:  143:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_10IONetCloseEE9GetResultEv:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetCloseEE9GetResultEv called 1 returned 100% blocks executed 100%
        1:  143:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        1:  143-block  0
call    0 returned 1
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE9GetResultEv:
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE9GetResultEv called 1 returned 100% blocks executed 100%
        1:  143:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        1:  143-block  0
call    0 returned 1
------------------
_ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE9GetResultEv:
function _ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE9GetResultEv called 1 returned 100% blocks executed 100%
        1:  143:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        1:  143-block  0
call    0 returned 1
------------------
        -:  144:        const Method& GetMethod() const { return method; }
        -:  145:        const IOStreamPtr& GetStream() const { return stream; }
        -:  146:    private:
        -:  147:        bool CallMethod(uv_loop_t *loop);
        -:  148:
        -:  149:        std::shared_ptr<Result<IOResult>>                        result;
        -:  150:        Method                                                   method;
        -:  151:        IOStreamPtr                                              stream;
        -:  152:    };
        -:  153:
        -:  154:
        -:  155:    template<>
        -:  156:    class IONetTaskImpl<IONetListen> : public IOTask {
        -:  157:    public:
        -:  158:        explicit IONetTaskImpl(IONetListen m, const TCPServerPtr& s) :
        -:  159:                method(m),
        -:  160:                server(s),
        -:  161:                result(new Result<IOResult>() ) {
        -:  162:        };
        -:  163:
        -:  164:
        -:  165:        bool Execute(uv_loop_t *loop) {
        -:  166:            return CallMethod(loop);
        -:  167:        }
        -:  168:
        -:  169:
        -:  170:        void Resolve(IOResult res) {
        -:  171:            result->SetValue(res);
        -:  172:        }
        -:  173:
        -:  174:
        -:  175:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        -:  176:        const IONetListen& GetMethod() const { return method; }
        -:  177:    private:
        -:  178:        inline bool CallMethod(uv_loop_s *loop);
        -:  179:
        -:  180:        TCPServerPtr                                             server;
        -:  181:        std::shared_ptr<Result<IOResult>>                        result;
        -:  182:        IONetListen                                              method;
        -:  183:    };
        -:  184:
        -:  185:
        -:  186:    template<>
        -:  187:    class IONetTaskImpl<IONetConnect> : public IOTask {
        -:  188:    public:
function _ZN12AsyncRuntime13IONetTaskImplINS_12IONetConnectEEC2ES1_RKSt10shared_ptrINS_13TCPConnectionEE called 1 returned 100% blocks executed 58%
        1:  189:        explicit IONetTaskImpl(IONetConnect m, const TCPConnectionPtr& c) :
        -:  190:                method(m),
        1:  191:                connection(c),
        1:  192:                result(new Result<IOResult>() ) {
        1:  192-block  0
call    0 returned 1
call    1 returned 1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0 (throw)
        1:  192-block  1
call    5 returned 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0 (throw)
        1:  192-block  2
call    8 returned 1
branch  9 taken 1 (fallthrough)
branch 10 taken 0 (throw)
    $$$$$:  192-block  3
call   11 never executed
        1:  193:        };
        1:  193-block  0
    $$$$$:  193-block  1
call    0 never executed
    $$$$$:  193-block  2
call    1 never executed
        -:  194:
        -:  195:
function _ZN12AsyncRuntime13IONetTaskImplINS_12IONetConnectEE7ExecuteEP9uv_loop_s called 1 returned 100% blocks executed 100%
        1:  196:        bool Execute(uv_loop_t *loop) {
        1:  197:            return CallMethod(loop);
        1:  197-block  0
call    0 returned 1
        -:  198:        }
        -:  199:
        -:  200:
function _ZN12AsyncRuntime13IONetTaskImplINS_12IONetConnectEE7ResolveEi called 1 returned 100% blocks executed 100%
        1:  201:        void Resolve(IOResult res) {
        1:  202:            result->SetValue(res);
        1:  202-block  0
call    0 returned 1
call    1 returned 1
        1:  203:        }
        -:  204:
        -:  205:
function _ZN12AsyncRuntime13IONetTaskImplINS_12IONetConnectEE9GetResultEv called 1 returned 100% blocks executed 100%
        1:  206:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        1:  206-block  0
call    0 returned 1
        -:  207:        const IONetConnect& GetMethod() const { return method; }
        -:  208:    private:
        -:  209:        inline bool CallMethod(uv_loop_s *loop);
        -:  210:
        -:  211:        TCPConnectionPtr                                         connection;
        -:  212:        std::shared_ptr<Result<IOResult>>                        result;
        -:  213:        IONetConnect                                             method;
        -:  214:    };
        -:  215:
        -:  216:
        -:  217:    template<>
        -:  218:    class IONetTaskImpl<IONetAddrInfo> : public IOTask {
        -:  219:    public:
        -:  220:        explicit IONetTaskImpl(IONetAddrInfo m, const NetAddrInfoPtr & i) :
        -:  221:                method(m),
        -:  222:                info(i),
        -:  223:                result(new Result<IOResult>() ) {
        -:  224:        };
        -:  225:
        -:  226:
        -:  227:        bool Execute(uv_loop_t *loop) {
        -:  228:            return CallMethod(loop);
        -:  229:        }
        -:  230:
        -:  231:
        -:  232:        void Resolve(IOResult res) {
        -:  233:            result->SetValue(res);
        -:  234:        }
        -:  235:
        -:  236:
        -:  237:        std::shared_ptr<Result<IOResult>> GetResult() { return result; }
        -:  238:        const IONetAddrInfo& GetMethod() const { return method; }
        -:  239:        const NetAddrInfoPtr& GetInfo() const { return info; }
        -:  240:    private:
        -:  241:        inline bool CallMethod(uv_loop_s *loop);
        -:  242:
        -:  243:        NetAddrInfoPtr                                           info;
        -:  244:        std::shared_ptr<Result<IOResult>>                        result;
        -:  245:        IONetAddrInfo                                            method;
        -:  246:    };
        -:  247:
        -:  248:
        -:  249:    template<>
        -:  250:    inline bool AsyncRuntime::IOFsTaskImpl<AsyncRuntime::IOFsOpen>::CallMethod(uv_loop_s *loop) {
        -:  251:        uv_fs_open(loop, &request, method.filename, method.flags, method.mode, &FsOpenCb);
        -:  252:        return true;
        -:  253:    }
        -:  254:
        -:  255:
        -:  256:    template<>
        -:  257:    inline bool AsyncRuntime::IOFsTaskImpl<AsyncRuntime::IOFsClose>::CallMethod(uv_loop_s *loop) {
        -:  258:        uv_file fd = stream->GetFd();
        -:  259:        uv_fs_close(loop, &request, fd, &FsCloseCb);
        -:  260:        return true;
        -:  261:    }
        -:  262:
        -:  263:
        -:  264:    template<>
        -:  265:    inline bool AsyncRuntime::IOFsTaskImpl<AsyncRuntime::IOFsRead>::CallMethod(uv_loop_s *loop) {
        -:  266:        stream->SetMode(IOStream::R);
        -:  267:        uv_buf_t *buf = stream->Next();
        -:  268:        uv_file fd = stream->GetFd();
        -:  269:        uv_fs_read(loop, &request, fd, buf, 1, method.seek, &FsReadCb);
        -:  270:        return true;
        -:  271:    }
        -:  272:
        -:  273:
        -:  274:    template<>
        -:  275:    inline bool AsyncRuntime::IOFsTaskImpl<AsyncRuntime::IOFsWrite>::CallMethod(uv_loop_s *loop) {
        -:  276:        stream->SetMode(IOStream::W);
        -:  277:        uv_file fd = stream->GetFd();
        -:  278:        uv_buf_t *buf = stream->Next();
        -:  279:        if(buf) {
        -:  280:            uv_fs_write(loop, &request, fd, buf, 1, method.seek, &FsWriteCb);
        -:  281:            return true;
        -:  282:        }else{
        -:  283:            Resolve(EIO);
        -:  284:            return false;
        -:  285:        }
        -:  286:    }
        -:  287:
        -:  288:
        -:  289:    inline bool AsyncRuntime::IONetTaskImpl<AsyncRuntime::IONetListen>::CallMethod(uv_loop_s *loop) {
        -:  290:        assert(server);
        -:  291:        int error = 0;
        -:  292:        uv_tcp_t *tcp_server = &server->server;
        -:  293:        tcp_server->data = this;
        -:  294:        uv_tcp_init(loop, tcp_server);
        -:  295:        uv_ip4_addr(server->hostname.c_str(), server->port, &server->bind_addr);
        -:  296:        error = uv_tcp_bind(tcp_server, (struct sockaddr*)&server->bind_addr, 0);
        -:  297:        if (error) {
        -:  298:            Resolve(error);
        -:  299:            return false;
        -:  300:        }
        -:  301:
        -:  302:        error = uv_listen((uv_stream_t*) tcp_server, 128 /*backlog*/, &NetConnectionCb);
        -:  303:        if (error) {
        -:  304:            Resolve(error);
        -:  305:            return false;
        -:  306:        }
        -:  307:
        -:  308:        return true;
        -:  309:    }
        -:  310:
        -:  311:
function _ZN12AsyncRuntime13IONetTaskImplINS_12IONetConnectEE10CallMethodEP9uv_loop_s called 1 returned 100% blocks executed 86%
        1:  312:    inline bool AsyncRuntime::IONetTaskImpl<AsyncRuntime::IONetConnect>::CallMethod(uv_loop_s *loop) {
       1*:  313:        assert(connection);
        1:  313-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%:  313-block  1
call    3 never executed
        1:  314:        uv_connect_t *con = &connection->connect;
        1:  314-block  0
call    0 returned 1
        1:  315:        con->data = this;
        1:  316:        uv_tcp_init(loop, &connection->socket);
call    0 returned 1
call    1 returned 1
        1:  317:        uv_tcp_keepalive(&connection->socket, 1, connection->keepalive);
call    0 returned 1
call    1 returned 1
call    2 returned 1
        1:  318:        uv_ip4_addr(connection->hostname.c_str(), connection->port, &connection->dest_addr);
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
call    4 returned 1
        1:  319:        int error = uv_tcp_connect(con, &connection->socket, (sockaddr*)&connection->dest_addr, &NetConnectionCb);
call    0 returned 1
call    1 returned 1
call    2 returned 1
        1:  320:        if(error) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  321:            Resolve(error);
    %%%%%:  321-block  0
call    0 never executed
    #####:  322:            return false;
        -:  323:        }
        -:  324:
        1:  325:        return true;
        1:  325-block  0
        -:  326:    }
        -:  327:
        -:  328:
        -:  329:    template<>
function _ZN12AsyncRuntime13IONetTaskImplINS_9IONetReadEE10CallMethodEP9uv_loop_s called 1 returned 100% blocks executed 75%
        1:  330:    inline bool AsyncRuntime::IONetTaskImpl<AsyncRuntime::IONetRead>::CallMethod(uv_loop_s *loop) {
       1*:  331:        assert(stream);
        1:  331-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%:  331-block  1
call    3 never executed
        1:  332:        stream->SetMode(IOStream::R);
        1:  332-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  333:        uv_tcp_t *tcp_client = method.socket;
        1:  334:        tcp_client->data = this;
        1:  335:        int error = uv_read_start((uv_stream_t*) tcp_client, &NetAllocCb, &NetReadCb);
        1:  335-block  0
call    0 returned 1
        1:  336:        if(error) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  337:            Resolve(error);
    %%%%%:  337-block  0
call    0 never executed
    #####:  338:            return false;
        -:  339:        }
        -:  340:
        1:  341:        return true;
        1:  341-block  0
        -:  342:    }
        -:  343:
        -:  344:
        -:  345:    template<>
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetWriteEE10CallMethodEP9uv_loop_s called 1 returned 100% blocks executed 71%
        1:  346:    inline bool AsyncRuntime::IONetTaskImpl<AsyncRuntime::IONetWrite>::CallMethod(uv_loop_s *loop) {
       1*:  347:        assert(stream);
        1:  347-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%:  347-block  1
call    3 never executed
        1:  348:        stream->SetMode(IOStream::W);
        1:  348-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  349:        auto *client = (uv_stream_t *)method.socket;
        1:  350:        uv_buf_t *buf = stream->Next();
        1:  350-block  0
call    0 returned 1
call    1 returned 1
        1:  351:        if(buf) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  352:            auto *write_req = (uv_write_t*)malloc(sizeof(uv_write_t));
        1:  353:            write_req->data = this;
        1:  354:            int error = uv_write(write_req, client, buf, 1, &NetWriteCb);
        1:  354-block  0
call    0 returned 1
        1:  355:            if(error) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  356:                Resolve(error);
    %%%%%:  356-block  0
call    0 never executed
    #####:  357:                return false;
        -:  358:            }
        1:  359:            return true;
        1:  359-block  0
        -:  360:        }else{
    #####:  361:            Resolve(EIO);
    %%%%%:  361-block  0
call    0 never executed
    #####:  362:            return false;
        -:  363:        }
        -:  364:    }
        -:  365:
        -:  366:
        -:  367:    template<>
function _ZN12AsyncRuntime13IONetTaskImplINS_10IONetCloseEE10CallMethodEP9uv_loop_s called 1 returned 100% blocks executed 100%
        1:  368:    inline bool AsyncRuntime::IONetTaskImpl<AsyncRuntime::IONetClose>::CallMethod(uv_loop_s *loop) {
        1:  369:        uv_tcp_t *tcp_client = method.socket;
        1:  370:        tcp_client->data = this;
        1:  371:        uv_close((uv_handle_t*) tcp_client, &NetCloseCb);
        1:  371-block  0
call    0 returned 1
        1:  372:        return true;
        -:  373:    }
        -:  374:
        -:  375:
        -:  376:    inline bool AsyncRuntime::IONetTaskImpl<AsyncRuntime::IONetAddrInfo>::CallMethod(uv_loop_s *loop) {
        -:  377:        assert(info);
        -:  378:        info->resolver.data = this;
        -:  379:        int error = uv_getaddrinfo(loop, &info->resolver, &NetAddrInfoCb, info->node.c_str(), NULL, &info->hints);
        -:  380:        if(error) {
        -:  381:            Resolve(error);
        -:  382:            return false;
        -:  383:        }
        -:  384:        return true;
        -:  385:    }
        -:  386:
        -:  387:
        -:  388:    template<typename Method>
        -:  389:    IOFsTaskImpl<Method>* IOFsTaskCast(void *task) {
        -:  390:        return static_cast<IOFsTaskImpl<Method>*>(task);
        -:  391:    }
        -:  392:
        -:  393:
        -:  394:    template<typename Method>
        -:  395:    IONetTaskImpl<Method>* IONetTaskCast(void *task) {
        -:  396:        return static_cast<IONetTaskImpl<Method>*>(task);
        -:  397:    }
        -:  398:}
        -:  399:
        -:  400:#endif //AR_IO_TASK_HPP
