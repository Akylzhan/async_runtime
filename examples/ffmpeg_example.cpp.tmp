#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <iostream>
#include <thread>

extern "C" {
#include "libavcodec/avcodec.h"
#include "libswscale/swscale.h"
#include "libavutil/imgutils.h"
#include "libavutil/opt.h"
#include "libavformat/avformat.h"
#include "libavformat/avio.h"
#include "libavformat/url.h"
#include "libavformat/version.h"
}

#include "ar/ar.hpp"
#include "ar/io/io.hpp"
#include "ffmpeg_tcp_context.h.tmp"
#include "ffmpeg_udp_context.h.tmp"
#include <boost/url/url_view.hpp>

using namespace AsyncRuntime;
using namespace std::chrono_literals;

static const struct URLProtocol * find_url_protocol(const char* filename, void *opaque) {
    std::cout << filename << std::endl;
    boost::urls::url_view uv(filename);
    std::string protocol = uv.scheme();
    if (protocol == "tcp") {
        return &tcp_protocol;
    } else if (protocol == "udp") {
        return &udp_protocol;
    } else {
        return NULL;
    }
}

static void alloc_context(void *context, void *opaque) {
    IOContext *s = (IOContext *)context;
    s->coro_handler = (coroutine_handler*)opaque;
}

static std::atomic_int count = {0};
static std::atomic_int pkt_count = {0};

void async_client(coroutine_handler* handler, yield<void> & yield) {
    auto tag = AddEntityTag((void*)handler);
    auto state = handler->get_execution_state();
    state.tag = tag;
    handler->set_execution_state(state);
    AVFormatContext *ifmt_ctx = NULL;
    AVPacket *pkt = NULL;
    const char *in_filename = "rtsp://127.0.0.1:5554/face.mp4";
    AVDictionary *opts = NULL;
    av_dict_set(&opts, "rtsp_transport", "tcp", 0);
    int ret = 0;

    pkt = av_packet_alloc();
    if (!pkt) {
        fprintf(stderr, "Could not allocate AVPacket\n");
        return;
    }

    if (!(ifmt_ctx = avformat_alloc_context())) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    ifmt_ctx->find_protocol_callback.find_callback = &find_url_protocol;
    ifmt_ctx->find_protocol_callback.alloc_callback = &alloc_context;
    ifmt_ctx->find_protocol_callback.opaque = handler;

    if ((ret = avformat_open_input(&ifmt_ctx, in_filename, 0, &opts)) < 0) {
        fprintf(stderr, "Could not open input file '%s'", in_filename);
        goto end;
    }

    if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) < 0) {
        fprintf(stderr, "Failed to retrieve input stream information");
        goto end;
    }

    av_dump_format(ifmt_ctx, 0, in_filename, 0);

    count++;
    std::cout << count.load() << std::endl;

    while (1) {
        ret = av_read_frame(ifmt_ctx, pkt);
        if (ret < 0)
            break;
        pkt_count++;
        //std::cout << pkt->size << std::endl;
        av_packet_unref(pkt);
    }

    end:
    std::cout << "close" << std::endl;
    av_packet_free(&pkt);

    avformat_close_input(&ifmt_ctx);

    if (ret < 0 && ret != AVERROR_EOF) {
        return;
    }
}


int main(int argc, char **argv)
{
    AsyncRuntime::Logger::s_logger.SetStd();
    SetupRuntime();

    for (int i = 0; i < 800; ++i) {
        Async(make_coroutine(&async_client));
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    for(;;) {
        sleep(1);
        std::cout << pkt_count.load() << std::endl;
        pkt_count.store(0);
    }

    Terminate();
    return 0;
}
